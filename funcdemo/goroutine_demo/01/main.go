package main

import (
	"fmt"
	"sync"
)

var wg sync.WaitGroup

// 协程介绍
func main() {
	/**
	关于进程和线程
	进程（process）：就是程序在操作系统中的一次执行过程。是系统进行资源分配和调度的基本单位，进程是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间。一个进程至少有5种基本状态：初始态、执行态、等待状态、就绪状态、终止状态。通俗的将进程就是一个正在执行的程序。
	线程：是进程的一个执行实例，是程序执行的最小单位，它是比进程更小的能独立运行的基本单位。
	一个进程可以创建多个线程，同一个进程中的多个线程可以并发执行，一个程序要运行的话至少有一个进程。

	关于并发和并行
	并行：多个线程可以同时执行，每一个时间段，可以有多个线程同时执行。
	并发：多个线程同时竞争一个位置，竞争到的才能执行，每一个时间只有一个线程在执行。
	通俗的将多线程在单核CPU上面运行就是并发，多线程在多核CPU上运行就是并行，如果线程数量大于CPU核数，则多个线程在多个CPU上运行既有并行也有并发
	*/

	/**
	golang中的主线程：（可以理解为线程也可以理解为进程），在一个golang程序的主线程上可以起多个协程。golang中多协程可以实现并行或者并发
	协程：可以理解为用户级线程，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的。
	golang的一大特色就是从语言层面上原生支持协程，在函数或者方法前面加一个go关键字就可以创建一个协程。可以说golang中的协程就是goroutine
	*/

	/**
	关于多线程和多协程
	golang中每个goroutine(协程)默认占用内存远比Java、C的线程少。
	os线程（操作系统线程）一般都有固定的栈内存（通常为2MB左右），一个goroutine占用内存非常小，只有2KB左右，多协程goroutine切换调度开销方面远比线程要少。
	*/

	// goroutine的使用以及sync.WaitGroup
	// go func1()
	// fmt.Println("主线程退出。。")
	// 上面的代码是有问题的。不会输出函数内的方法打印值，因为主线程结束，协程就停止了
	// 使用sync.WaitGroup让主线程等待协程执行完成再退出
	wg.Add(1)  // 协程计数器+1
	go func1() // 表示开启一个协程
	wg.Wait()  // 等待协程执行完成通知
	fmt.Println("主线程退出。。")
}

func func1() {
	defer wg.Done() // 协程计数器-1
	for i := 1; i <= 5; i++ {
		fmt.Println("协程中打印的数字，", i)
	}
}
