package main

import "fmt"

// 指针
// &获取对象的指针
// *声明和定义指针，也操作指针变量
func main() {
	// 在计算机底层，每一个变量其实对应了一个内存地址

	a := 10
	fmt.Printf("a的值：%d，a的类型：%T，a的内存地址：%p \n", a, a, &a)

	// 指针也是一个变量，但它是一种特殊的变量，它存储的数据不是一个普通的值，而是另外一个变量的内存地址
	a1 := 10
	p1 := &a1 // p1是一个指针变量  *int指针类型  指针变量p1也有内存地址
	fmt.Printf("a1的值：%d，a1的类型：%T，a1的内存地址：%p \n", a1, a1, &a1)
	fmt.Printf("p1的值：%v，p1的类型：%T，p1的内存地址：%p \n", p1, p1, &p1)
	/**
	a1的值：10，a1的类型：int，a1的内存地址：0xc0000c2018
	p1的值：0xc0000c2018，p1的类型：*int，p1的内存地址：0xc0000c4020
	*/
	a2 := *p1 // *p1表示取出p1这个变量对应的内存地址的值
	fmt.Println(a2)

	fmt.Println("--------------------------------------")
	var x int = 5
	func1(5)
	fmt.Println(x)
	func2(&x)
	fmt.Println(x)

	fmt.Println("--------------------------------------")
	// make()和new()
	// 引用类型必须分配内存空间后才能赋值

	var t1 = new(int) // t1是一个指针变量，并且改指针对应的值为0
	fmt.Printf("t1的值：%v，t1的类型：%T，t1的内存地址：%p，t1的值：%v，，t1的值的内存地址：%v \n", t1, t1, &t1, *t1, t1)
	/**
	make和new的区别
	1.二者都是用来分配内存的
	2.make只用于slice，map，channel的初始化，返回的还是这三个引用类型本身
	3.而new用与类型的内存分配，并且内存对应的值为初始化类型的默认值，返回的是（指向类型值的指针）
	*/
}

func func1(x int) {
	// 调这个方法，会将传参先赋值给x,然后执行x=10,但是不会改变传递的参数的值
	x = 10
}

func func2(x *int) {
	// 这里入参为指针，会将入参指针赋值给x，此时x的内存地址与入参的内存地址相等，
	// 所以执行*x=20后，变量x的内存地址对应的值修改为20
	*x = 20
}
